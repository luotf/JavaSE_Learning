# 三.多线程
## 1. 进程和线程

```
1. 进程：正在进行的程序。每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。
2. 线程：是进程内部的一条执行路径或者一个控制单元。
3. 两者的区别
     (1)一个进程至少有一个线程。
     (2)进程在执行过程中拥有独立的内存单元，而多个线程共享内存。
```

## 2. Jvm的启动是多线程吗？

```
是多线程。
Jvm启动至少有两个线程，一个执行Java程序，一个执行垃圾回收。
如果是单线程，就有可能发生内存泄露。
```

## 3. 多线程的优势及弊端

```
1. 优势：解决了多部分同时运行的问题，提高效率。
2. 弊端：线程太多会导致效率的降低，因为线程的执行依靠的是CPU的来回切换。
```

## 4. 实现多线程的两种方法

```
实现多线程可以通过继承Thread类和实现Runnable接口。
1. 继承Thread
     (1)定义一个类继承Thread类。
     (2)复写Thread类中的public void run()方法，将线程的任务代码封装到run方法中。
     (3)直接创建Thread的子类对象，创建线程。
     (4)调用start()方法，开启线程(调用线程的任务run方法)。
      //也可以通过Thread的getName()获取线程的名称。
2. 实现Runnable接口
     (1)定义一个类，实现Runnable接口。
     (2)覆盖接口的public void run()的方法，将线程的任务代码封装到run方法中。
     (3)创建Runnable接口的子类对象。
     (4)将Runnabl接口的子类对象作为参数传递给Thread类的构造函数，创建Thread类对象
     (原因：线程的任务都封装在Runnable接口子类对象的run方法中。所以要在线程对象创建时就必须明确要运行的任务)。
     (5)调用start()方法，启动线程。
	
3. 两种方法区别
     (1)实现Runnable接口：避免了单继承的局限性。
     (2)继承Thread类：线程代码存放在Thread子类的run方法中。
     (3)实现Runnable接口：线程代码存放在接口的子类的run方法中。
     在定义线程时，建议使用实现Runnable接口，因为几乎所有多线程都可以使用这种方式实现。
```

## 5. 创建线程是为什么要复写run方法？
	
```
Thread类用于描述线程。
Thread类定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。
```

## 6. start()和run方法有什么区别？
	
```
调用start方法可启动线程，而run方法只是thread的一个普通方法，调用run方法不能实现多线程。
1. Start()方法
     (1)start方法用来启动线程,实现了多线程运行,这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。
     (2)通过调用Thread类的start()方法来启动一个线程,这时此线程处于就绪(可运行)状态，并没有运行；
     一旦得到cpu时间片(执行权),就开始执行run()方法,这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束,此线程随即终止。	
2. Run()方法
     (1)run()方法只是Thread类的一个普通方法,如果直接调用Run方法,程序中依然只有主线程这一个线程,其程序执行路径还是只有一条，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。
```

## 7. 线程的几种状态

```
1. 新建
     (1)new一个Thread对象或者其子类对象就是创建一个线程。
     (2)当一个线程对象被创建，但是没有开启，这个时候，只是对线程对象开辟了内存空间和初始化数据。	        
2. 就绪
     (1)新建的对象调用start方法，就开启了线程，线程就到了就绪状态。
     (2)在这个状态的线程对象，具有执行资格，没有执行权。
3. 运行
     (1)当线程对象获取到了CPU的资源。
     (2)在这个状态的线程对象，既有执行资格，也有执行权。
4. 冻结
     (1)运行过程中的线程由于某些原因(比如wait,sleep)，释放了执行资格和执行权。
     (2)他们也可以回到运行状态。只不过，不是直接回到。而是先回到就绪状态。
5. 死亡
     (1)当线程对象调用的run方法结束，或者直接调用stop方法，就让线程对象死亡，在内存中变成了垃圾。
```
## 8. sleep()和wait()的区别
	 
```
1. 这两个方法来自不同的类。sleep()来自Thread类，wait()来自Object类。
2. sleep()是Thread的静态类方法，谁调用的谁去睡觉(即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep)；
    wait()是Object类的非静态方法。
3. sleep()释放资源不释放锁，而wait()释放资源释放锁。
4. 使用范围
     (1)wait(),notify()和notifyAll()只能在同步控制方法或者同步控制块里面使用。
     (2)sleep()可以在任何地方使用。
```

## 9. 多线程安全问题

```
1. 原因
     当程序的多条语句在操作线程共享数据时(如买票例子中的票就是共享资源)，由于线程的随机性导致一个线程对多条语句，执行了一部分还没执行完，另一个线程抢夺到cpu执行权参与进来执行，此时就导致共享数据发生错误。比如买票例子中打印重票和错票的情况。	
2. 解决方法
     对多条操作共享数据的语句进行同步，一个线程在执行过程中其他线程不可以参与进来。
```

## 10. Java中多线程同步是什么？

```
同步是用来解决多线程的安全问题的。(在多线程中，同步能控制对共享数据的访问。如果没有同步，当一个线程在修改一个共享数据时，而另外一个线程正在使用或者更新同一个共享数据，这样容易导致程序出现错误的结果)。
```

## 11. 什么是锁?锁的作用是什么?

```
1. 锁就是对象。
2. 锁的作用：保证线程同步，解决线程安全问题。
3. 持有锁的线程可以在同步中执行，没有锁的线程即使获得cpu执行权，也进不去。
```

## 12. 同步的前提

```
1. 必须保证有两个以上线程。
2. 必须是多个线程使用同一个锁(即多条语句在操作线程共享数据)。
3. 必须保证同步中只有一个线程在运行。
```

## 13. 同步的好处和弊端

```
1. 好处：同步解决了多线程的安全问题。
2. 弊端：多线程都需要判断锁，比较消耗资源。
```

## 14. 同步的两种表现形式

```
1. 同步代码块
     可以指定需要获取哪个对象的同步锁,使用synchronized的代码块同样需要锁,但他的锁可以是任意对象。
     //考虑到安全问题，一般还是使用同一个对象，相对来说效率较高。
    注意：
        (1)虽然同步代码快的锁可以使任何对象，但是在进行多线程通信使用同步代码快时，必须保证同步代码块的锁的对象和，否则会报错。
        (2)同步函数的锁是this，也要保证同步函数的锁的对象和调用wait、notify和notifyAll的对象是同一个对象，也就是都是this锁代表的对象。
    格式：
        synchronized(对象){
           需同步的代码;
        }
2. 同步方法
     同步方法是指进入该方法时需要获取this对象的同步锁。
     在方法上使用synchronized关键字，使用this对象作为锁，也就是使用了当前对象。
     //因为锁住了方法，所以相对于代码块来说效率相对较低。
    注意:
        静态同步函数的锁是该方法所在的类的字节码文件对象，即类名.class文件。
    格式：
        修饰词 synchronized 返回值类型 函数名(参数列表){
           需同步的代码;
        }

    在jdk1.5后，用lock锁取代了synchronized。
```

## 15 .多线程的单例设计模式

```
保证某个类中内存中只有一个对象
1. 饿汉式
     class Single{
        private Single(){}//将构造函数私有化，不让别的类建立该类对象
        private static final Single s=new Single();//自己建立一个对象
        public static Single getInstance(){//提供一个公共访问方式
              return s;
             }
        }
2. 懒汉式
     class Single{
        private Single(){} 
        private static Single s;
        public static Single getInstance(){
           if(s==null)
              s=new Single();
              return s;
           }
        }
3. 饿汉式和懒汉式的区别
     (1)饿汉式是类一加载进内存就创建好了对象；
     (2)懒汉式则是类加载进内存的时候，对象还没有存在，只有调用了getInstance()方法时，对象才开始创建。
     (3)懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题。
         解决线程安全问题：可以加同步来解决(但是加了同步之后，每一次都要比较锁，效率就变慢了)。所以可以加双重判断来提高程序效率。
    
     如：将上述懒汉式的Instance函数改成同步
        public static Single getInstance(){
           if(s==null){
              synchronized(Single.class){
                 if(s==null) 
                 s=new Single();
              }
           }
           return s;
        }
```

## 16. 死锁

```
两个线程对两个同步对象具有循环依赖时，就会发生死锁。即同步嵌套同步，而锁却不同。
```

## 17. wait()、sleep()、notify()、notifyAll()

```
1. wait()：使一个线程处于等待状态，并且释放所持有的对象的lock。 
2. sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 
3. notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程(一般是最先开始等待的线程)，而且不是按优先级。 
4. notifyAll()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。
```

## 18. 为什么wait()、notify()、notifyAll()这些用来操作线程的方法定义在Object类中？
	
```
1. 这些方法只存在于同步中。
2. 使用这些方法时必须要指定所属的锁，即被哪个锁调用这些方法。
3. 锁可以是任意对象，所以任意对象调用的方法就定义在Object中。
```

## 19. 多线程间通讯

```
多线程间通讯就是多个线程在操作同一资源,但是操作的动作不同。
1. 为什么要通信
     多线程并发执行的时候,如果需要指定线程等待或者唤醒指定线程,那么就需要通信。
     (比如：生产者消费者的问题，生产一个消费一个,生产的时候需要负责消费的进程等待,
     生产一个后完成后需要唤醒负责消费的线程,同时让自己处于等待，消费的时候负责消费的线程被唤醒，
     消费完生产的产品后又将等待的生产线程唤醒，然后使自己线程处于等待。
     这样来回通信，以达到生产一个消费一个的目的。)
2. 怎么通信
     在同步代码块中, 使用锁对象的wait()方法可以让当前线程等待,直到有其他线程唤醒为止。
     使用锁对象的notify()方法可以唤醒一个等待的线程，或者notifyAll唤醒所有等待的线程。
    多线程间通信用sleep()很难实现，睡眠时间很难把握。
```

	
	
## 20. Lock和Condition

```
1. Lock是个接口
2. 锁是控制多个线程对共享数据进行访问的工具。

3. JDK1.5中提供了多线程升级的解决方案
     将同步synchonized替换成了显示的Lock操作，将Object中的wait、notify、notifyAll替换成了Condition对象。
4. Lock的方法摘要
     (1)void lock()：获取锁。 
     (2)Condition newCondition()：返回绑定到此 Lock 实例的新 Condition 实例。 
     (3)void unlock()：释放锁。
5. Condition方法摘要
     (1)void await()：造成当前线程在接到信号或被中断之前一直处于等待状态。
     (2)void signal()：唤醒一个等待线程。          
     (3)void signalAll()：唤醒所有等待线程。
```

## 21. 停止线程
	
```
1. stop方法已经过时，如何停止线程？
     停止线程的方法只有一种：就是run方法结束。
2. 如何让run方法结束呢？
     开启多线程运行，运行代码通常是循环体，只要控制住循环，就可以让run方法结束，也就是结束线程。

   特殊情况：当线程属于冻结状态，就不会读取循环控制标记，则线程就不会结束。
   解决该特殊情况：可引入Thread类中的Interrupt方法结束线程的冻结状态。
   当没有指定的方式让冻结线程恢复到运行状态时，需要对冻结进行清除，强制让线程恢复到运行状态。
```

## 22. interrupt

```
void interrupt()：中断线程。
中断状态将被清除，它还将收到一个 InterruptedException。
```

## 23. 守护线程(后台线程)

```
1. setDaemon(boolean on)：将该线程标记为守护线程或者用户线程。
2. 特点
     守护线程开启后和前台线程共同抢夺cpu的执行权，开启、运行两者都没区别，但结束时有区别，当所有前台线程都结束后，守护线程会自动结束。
3. 注意
     (1)当主线程结束，守护线程自动结束。
     (2)当正在运行的线程都是守护线程时，java虚拟机jvm退出；所以该方法必须在启动线程前调用。
```
		
## 24. 多线程join方法
	
```
1. void join()：等待该线程终止。
2. void join(long millis)：等待该线程终止的时间最长为 millis 毫秒。
3. 特点：当A线程执行到B线程的join方法时，A就会等待B线程都执行完，A才会执行
4. 作用: join可以用来临时加入线程执行。
```

## 25. 多线程优先级：yield()方法

```
1. yield()：暂停当前正在执行的线程对象，并执行其他线程。
2. setPriority(int newPriority)：更改线程优先级。
     (1)MAX_PRIORITY:最高优先级(10级)。
     (2)Min_PRIORITY:最低优先级(1级)。
     (3)Morm_PRIORITY:默认优先级(5级)。
3. int getPriority()：返回线程的优先级。
4. String toString()：返回该线程的字符串表示形式，包括线程名称、优先级和线程组。
           
```


## 26. 什么是ThreadLocal类,怎么使用它？

```
1. ThreadLocal类提供了线程局部 (thread-local) 变量。是一个线程级别的局部变量，并非“本地线程”。
2. ThreadLocal 为每个使用该变量的线程,提供了一个独立的变量副本，每个线程修改副本时不影响其它线程对象的副本。
```

## 27. 什么时候抛出InvalidMonitorStateException异常?为什么？

```
1. 当调用 wait ()/notify ()/notifyAll()中的任何一个方法时，如果当前线程没有获得该对象的锁，那么就会抛出 IllegalMonitorStateException 的异常。
2. 也就是说程序在没有执行对象的任何同步块或者同步方法时，仍然尝试调用 wait ()/notify ()/notifyAll ()时。
```

## 28. 在静态方法上使用同步时会发生什么事？
	
```
同步静态方法时会获取该类的“Class”对象，所以当一个线程进入同步的静态方法中时，线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。
它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。
```

## 29. 当一个同步方法已经执行，线程能够调用对象上的非同步实例方法吗？

```
可以，一个非同步方法总是可以被调用而不会有任何问题。
```

## 30. 在一个对象上两个线程可以调用两个不同的同步实例方法吗？
	
```
不能，因为一个对象已经同步了实例方法，线程获取了对象的对象锁。
所以只有执行完该方法释放对象锁后才能执行其它同步方法。
```

## 31. 什么是线程饥饿，什么是死锁/活锁？

```
1. 饥饿
     是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。与死锁和活锁非常相似。
     (比如：这是个独木桥(单进程),桥上只能走一个人,B来到时A在桥上,B等待;
     而此时比B年龄小的C来了,B让C现行(A走完后系统把进程分给了C),
     C上桥后,D又来了,B又让D现行(C走完后系统把进程分个了D)以此类推B一直是等待状态。)
2. 死锁
     指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。
     (比如：线程A或者B需要过独木桥(使用该进程),而C还没有走完(进程还在占用),于是三方僵死;
     也可以是没有C的情况下,A和B互不礼让僵死。A和B都认为自己优先级较高应该使用该进程。)
3. 活锁
     活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。
     (比如：线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源
     。这样你让我，我让你，最后两个线程都无法使用资源。)

```
